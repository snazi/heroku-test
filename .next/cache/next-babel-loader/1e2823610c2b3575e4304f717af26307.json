{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useCallback, useMemo, useState, useEffect } from 'react';\nimport isHotkey from 'is-hotkey';\nimport { Editable, withReact, useSlate, Slate } from 'slate-react';\nimport { Editor, Transforms, createEditor, Node, Text } from 'slate';\nimport { withHistory } from 'slate-history';\nimport ControllMenu from './ControllMenu';\nimport escapeHtml from 'escape-html';\nimport { jsx } from 'slate-hyperscript';\nimport { Button, Icon, Toolbar } from './components';\nconst HOTKEYS = {\n  'mod+b': 'bold',\n  'mod+i': 'italic',\n  'mod+u': 'underline',\n  'mod+`': 'code'\n};\nconst LIST_TYPES = ['numbered-list', 'bulleted-list'];\n\nconst serialize = node => {\n  if (Text.isText(node)) {\n    return escapeHtml(node.text);\n  }\n\n  const children = node.children.map(n => serialize(n)).join('');\n\n  switch (node.type) {\n    case 'block-quote':\n      return `<blockquote><p>${children}</p></blockquote>`;\n\n    case 'paragraph':\n      return `<p>${children}</p>`;\n\n    case 'link':\n      return `<a href=\"${escapeHtml(node.url)}\">${children}</a>`;\n\n    case 'code':\n      return `ahahahah tangina`;\n\n    default:\n      return children;\n  }\n};\n\nconst deserialize = el => {\n  if (el.nodeType === 3) {\n    return el.textContent;\n  } else if (el.nodeType !== 1) {\n    return null;\n  }\n\n  const children = Array.from(el.childNodes).map(deserialize);\n\n  switch (el.nodeName) {\n    case 'BODY':\n      return jsx('fragment', {}, children);\n\n    case 'BR':\n      return '\\n';\n\n    case 'BLOCKQUOTE':\n      return jsx('element', {\n        type: 'quote'\n      }, children);\n\n    case 'P':\n      return jsx('element', {\n        type: 'paragraph'\n      }, children);\n\n    case 'A':\n      return jsx('element', {\n        type: 'link',\n        url: el.getAttribute('href')\n      }, children);\n\n    default:\n      return el.textContent;\n  }\n};\n\nconst initializeEditorWithProps = (props, setValue) => {\n  useEffect(() => {\n    const document = new DOMParser().parseFromString(props.initialValue, 'text/html');\n    const final = deserialize(document.body);\n    setValue(final);\n  }, []);\n};\n\nconst getTitle = value => {\n  const firstBlock = serialize(value.children[0]);\n  const secondBlock = value.children[1] ? serialize(value.children[1]) : null;\n  console.log(firstBlock);\n  const title = firstBlock ? firstBlock : 'No Title';\n  const subtitle = secondBlock ? secondBlock : 'No Subtitle';\n  return {\n    title,\n    subtitle\n  };\n};\n\nconst save = (props, value) => {\n  const headingValues = getTitle(value);\n  const text = serialize(value);\n  console.log(headingValues);\n  !props.isSaving && props.save(headingValues, text);\n};\n\nconst RichText = props => {\n  const {\n    0: value,\n    1: setValue\n  } = useState(initialValue);\n  if (props.initialValue) useEffect(() => {\n    const document = new DOMParser().parseFromString(props.initialValue, 'text/html');\n    const final = deserialize(document.body);\n    setValue(final);\n  }, []);\n  const renderElement = useCallback(props => __jsx(Element, props), []);\n  const renderLeaf = useCallback(props => __jsx(Leaf, props), []);\n  const editor = useMemo(() => withHistory(withReact(createEditor())), []);\n  const {\n    isSaving\n  } = props;\n  return __jsx(React.Fragment, null, __jsx(ControllMenu, {\n    isSaving: isSaving,\n    save: () => save(props, editor)\n  }), __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: value => setValue(value)\n  }, __jsx(Toolbar, null, __jsx(MarkButton, {\n    format: \"bold\",\n    icon: \"format_bold\"\n  }), __jsx(MarkButton, {\n    format: \"italic\",\n    icon: \"format_italic\"\n  }), __jsx(MarkButton, {\n    format: \"underline\",\n    icon: \"format_underlined\"\n  }), __jsx(MarkButton, {\n    format: \"code\",\n    icon: \"code\"\n  }), __jsx(BlockButton, {\n    format: \"heading-one\",\n    icon: \"looks_one\"\n  }), __jsx(BlockButton, {\n    format: \"heading-two\",\n    icon: \"looks_two\"\n  }), __jsx(BlockButton, {\n    format: \"block-quote\",\n    icon: \"format_quote\"\n  }), __jsx(BlockButton, {\n    format: \"numbered-list\",\n    icon: \"format_list_numbered\"\n  }), __jsx(BlockButton, {\n    format: \"bulleted-list\",\n    icon: \"format_list_bulleted\"\n  })), __jsx(Editable, {\n    renderElement: renderElement,\n    renderLeaf: renderLeaf,\n    placeholder: \"Enter some rich text\\u2026\",\n    spellCheck: true,\n    autoFocus: true,\n    onKeyDown: event => {\n      for (const hotkey in HOTKEYS) {\n        if (isHotkey(hotkey, event)) {\n          event.preventDefault();\n          const mark = HOTKEYS[hotkey];\n          toggleMark(editor, mark);\n        }\n      }\n    }\n  })));\n};\n\nconst toggleBlock = (editor, format) => {\n  const isActive = isBlockActive(editor, format);\n  const isList = LIST_TYPES.includes(format);\n  Transforms.unwrapNodes(editor, {\n    match: n => LIST_TYPES.includes(n.type),\n    split: true\n  });\n  Transforms.setNodes(editor, {\n    type: isActive ? 'paragraph' : isList ? 'list-item' : format\n  });\n\n  if (!isActive && isList) {\n    const block = {\n      type: format,\n      children: []\n    };\n    Transforms.wrapNodes(editor, block);\n  }\n};\n\nconst toggleMark = (editor, format) => {\n  const isActive = isMarkActive(editor, format);\n\n  if (isActive) {\n    Editor.removeMark(editor, format);\n  } else {\n    Editor.addMark(editor, format, true);\n  }\n};\n\nconst isBlockActive = (editor, format) => {\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === format\n  });\n  return !!match;\n};\n\nconst isMarkActive = (editor, format) => {\n  const marks = Editor.marks(editor);\n  return marks ? marks[format] === true : false;\n};\n\nconst Element = ({\n  attributes,\n  children,\n  element\n}) => {\n  switch (element.type) {\n    case 'block-quote':\n      return __jsx(\"blockquote\", attributes, children);\n\n    case 'bulleted-list':\n      return __jsx(\"ul\", attributes, children);\n\n    case 'heading-one':\n      return __jsx(\"h1\", attributes, children);\n\n    case 'heading-two':\n      return __jsx(\"h2\", attributes, children);\n\n    case 'list-item':\n      return __jsx(\"li\", attributes, children);\n\n    case 'numbered-list':\n      return __jsx(\"ol\", attributes, children);\n\n    default:\n      return __jsx(\"p\", attributes, children);\n  }\n};\n\nconst Leaf = ({\n  attributes,\n  children,\n  leaf\n}) => {\n  if (leaf.bold) {\n    children = __jsx(\"strong\", null, children);\n  }\n\n  if (leaf.code) {\n    children = __jsx(\"code\", null, children);\n  }\n\n  if (leaf.italic) {\n    children = __jsx(\"em\", null, children);\n  }\n\n  if (leaf.underline) {\n    children = __jsx(\"u\", null, children);\n  }\n\n  return __jsx(\"span\", attributes, children);\n};\n\nconst BlockButton = ({\n  format,\n  icon\n}) => {\n  const editor = useSlate();\n  return __jsx(Button, {\n    active: isBlockActive(editor, format),\n    onMouseDown: event => {\n      event.preventDefault();\n      toggleBlock(editor, format);\n    }\n  }, __jsx(Icon, null, icon));\n};\n\nconst MarkButton = ({\n  format,\n  icon\n}) => {\n  const editor = useSlate();\n  return __jsx(Button, {\n    active: isMarkActive(editor, format),\n    onMouseDown: event => {\n      event.preventDefault();\n      toggleMark(editor, format);\n    }\n  }, __jsx(Icon, null, icon));\n};\n\nconst initialValue = [{\n  type: 'paragraph',\n  children: [{\n    text: 'This is editable '\n  }, {\n    text: 'rich',\n    bold: true\n  }, {\n    text: ' text, '\n  }, {\n    text: 'much',\n    italic: true\n  }, {\n    text: ' better than a '\n  }, {\n    text: '<textarea>',\n    code: true\n  }, {\n    text: '!'\n  }]\n}, {\n  type: 'paragraph',\n  children: [{\n    text: \"Since it's rich text, you can do things like turn a selection of text \"\n  }, {\n    text: 'bold',\n    bold: true\n  }, {\n    text: ', or add a semantically rendered block quote in the middle of the page, like this:'\n  }]\n}, {\n  type: 'block-quote',\n  children: [{\n    text: 'A wise quote.'\n  }]\n}, {\n  type: 'paragraph',\n  children: [{\n    text: 'Try it out for yourself!'\n  }]\n}];\nexport default RichText;","map":null,"metadata":{},"sourceType":"module"}
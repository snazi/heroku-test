{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// Import React dependencies.\nimport React, { useEffect, useMemo, useState, useCallback } from \"react\"; // Import the Slate editor factory.\n\nimport { createEditor, Editor, Transforms, Text } from 'slate'; // Import the Slate components and React plugin.\n\nimport { Slate, Editable, withReact } from 'slate-react';\nconst CustomEditor = {\n  isBoldMarkActive(editor) {\n    const [match] = Editor.nodes(editor, {\n      match: n => n.bold === true,\n      universal: true\n    });\n    return !!match;\n  },\n\n  isCodeBlockActive(editor) {\n    const [match] = Editor.nodes(editor, {\n      match: n => n.type === 'code'\n    });\n    return !!match;\n  },\n\n  toggleBoldMark(editor) {\n    const isActive = CustomEditor.isBoldMarkActive(editor);\n    Transforms.setNodes(editor, {\n      bold: isActive ? null : true\n    }, {\n      match: n => Text.isText(n),\n      split: true\n    });\n  },\n\n  toggleCodeBlock(editor) {\n    const isActive = CustomEditor.isCodeBlockActive(editor);\n    Transforms.setNodes(editor, {\n      type: isActive ? null : 'code'\n    }, {\n      match: n => Editor.isBlock(editor, n)\n    });\n  }\n\n};\n\nconst DefaultElement = props => {\n  return __jsx(\"p\", props.attributes, props.children);\n};\n\nconst Leaf = props => {\n  return __jsx(\"span\", _extends({}, props.attributes, {\n    style: {\n      fontWeight: props.leaf.bold ? 'bold' : 'normal'\n    }\n  }), props.children);\n};\n\nconst SlateEditor = () => {\n  const editor = useMemo(() => withReact(createEditor()), []);\n  const {\n    0: value,\n    1: setValue\n  } = useState([{\n    type: 'paragraph',\n    children: [{\n      text: 'A line of text in a paragraph.'\n    }]\n  }]);\n  const renderLeaf = useCallback(props => {\n    return __jsx(Leaf, props);\n  }, []);\n  const renderElement = useCallback(props => {\n    switch (props.element.type) {\n      case 'code':\n        return __jsx(CodeElement, props);\n\n      default:\n        return __jsx(DefaultElement, props);\n    }\n  }, []);\n  return __jsx(Slate, {\n    editor: editor,\n    value: value,\n    onChange: newValue => setValue(newValue)\n  }, __jsx(Editable, {\n    renderElement: renderElement,\n    renderLeaf: renderLeaf,\n    onKeyDown: event => {\n      if (!event.ctrlKey) {\n        return;\n      } // Replace the `onKeyDown` logic with our new commands.\n\n\n      switch (event.key) {\n        case '`':\n          {\n            event.preventDefault();\n            CustomEditor.toggleCodeBlock(editor);\n            break;\n          }\n\n        case 'b':\n          {\n            event.preventDefault();\n            CustomEditor.toggleBoldMark(editor);\n            break;\n          }\n      }\n    }\n  }));\n};\n\nexport default SlateEditor;","map":{"version":3,"sources":["E:/Documents/Projects/heroku potfolio test/heroku-test/components/slate-editor/Editor.js"],"names":["React","useEffect","useMemo","useState","useCallback","createEditor","Editor","Transforms","Text","Slate","Editable","withReact","CustomEditor","isBoldMarkActive","editor","match","nodes","n","bold","universal","isCodeBlockActive","type","toggleBoldMark","isActive","setNodes","isText","split","toggleCodeBlock","isBlock","DefaultElement","props","attributes","children","Leaf","fontWeight","leaf","SlateEditor","value","setValue","text","renderLeaf","renderElement","element","newValue","event","ctrlKey","key","preventDefault"],"mappings":"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","sourcesContent":["// Import React dependencies.\r\nimport React, { useEffect, useMemo, useState, useCallback } from \"react\";\r\n// Import the Slate editor factory.\r\nimport { createEditor, Editor, Transforms, Text } from 'slate'\r\n\r\n// Import the Slate components and React plugin.\r\nimport { Slate, Editable, withReact } from 'slate-react'\r\n\r\nconst CustomEditor = {\r\n  isBoldMarkActive(editor) {\r\n    const [match] = Editor.nodes(editor, {\r\n      match: n => n.bold === true,\r\n      universal: true,\r\n    })\r\n\r\n    return !!match\r\n  },\r\n\r\n  isCodeBlockActive(editor) {\r\n    const [match] = Editor.nodes(editor, {\r\n      match: n => n.type === 'code',\r\n    })\r\n\r\n    return !!match\r\n  },\r\n\r\n  toggleBoldMark(editor) {\r\n    const isActive = CustomEditor.isBoldMarkActive(editor)\r\n    Transforms.setNodes(\r\n      editor,\r\n      { bold: isActive ? null : true },\r\n      { match: n => Text.isText(n), split: true }\r\n    )\r\n  },\r\n\r\n  toggleCodeBlock(editor) {\r\n    const isActive = CustomEditor.isCodeBlockActive(editor)\r\n    Transforms.setNodes(\r\n      editor,\r\n      { type: isActive ? null : 'code' },\r\n      { match: n => Editor.isBlock(editor, n) }\r\n    )\r\n  },\r\n}\r\n\r\nconst DefaultElement = props => {\r\n  return <p {...props.attributes}>{props.children}</p>\r\n}\r\n\r\nconst Leaf = props => {\r\n  return (\r\n    <span\r\n      {...props.attributes}\r\n      style={{ fontWeight: props.leaf.bold ? 'bold' : 'normal' }}\r\n    >\r\n      {props.children}\r\n    </span>\r\n  )\r\n}\r\n\r\nconst SlateEditor = () => {\r\n  const editor = useMemo(() => withReact(createEditor()), [])\r\n  const [value, setValue] = useState([\r\n    {\r\n      type: 'paragraph',\r\n      children: [{ text: 'A line of text in a paragraph.' }],\r\n    },\r\n  ])\r\n\r\n  const renderLeaf = useCallback(props => {\r\n    return <Leaf {...props} />\r\n  }, [])\r\n\r\n  const renderElement = useCallback(props => {\r\n    switch (props.element.type) {\r\n      case 'code':\r\n        return <CodeElement {...props} />\r\n      default:\r\n        return <DefaultElement {...props} />\r\n    }\r\n  }, [])\r\n      return( \r\n        <Slate editor={editor} value={value} onChange={newValue => setValue(newValue)}>\r\n            <Editable \r\n              renderElement={renderElement}\r\n              renderLeaf={renderLeaf}\r\n              onKeyDown={event => {\r\n                if (!event.ctrlKey) {\r\n                  return\r\n                }\r\n      \r\n                // Replace the `onKeyDown` logic with our new commands.\r\n                switch (event.key) {\r\n                  case '`': {\r\n                    event.preventDefault()\r\n                    CustomEditor.toggleCodeBlock(editor)\r\n                    break\r\n                  }\r\n      \r\n                  case 'b': {\r\n                    event.preventDefault()\r\n                    CustomEditor.toggleBoldMark(editor)\r\n                    break\r\n                  }\r\n                }\r\n              }}\r\n            />\r\n        </Slate>\r\n    )\r\n}\r\n\r\nexport default SlateEditor\r\n"]},"metadata":{},"sourceType":"module"}